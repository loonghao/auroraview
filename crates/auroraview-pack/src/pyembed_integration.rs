//! PyOxidizer/pyembed integration for AuroraView
//!
//! This module provides integration with PyOxidizer's pyembed crate to enable
//! standalone executables with embedded Python runtime.
//!
//! ## Architecture
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────┐
//! │                    Standalone Executable                     │
//! ├─────────────────────────────────────────────────────────────┤
//! │  AuroraView (Rust)                                          │
//! │  ├── WebView (wry/tao)                                      │
//! │  ├── Embedded Frontend (rust-embed)                         │
//! │  └── Embedded Python (pyembed)                              │
//! │       ├── Python Interpreter                                │
//! │       ├── Standard Library                                  │
//! │       └── User Python Code                                  │
//! └─────────────────────────────────────────────────────────────┘
//! ```
//!
//! ## Usage
//!
//! The pack command generates a project that can optionally include an embedded
//! Python runtime for running backend code:
//!
//! ```bash
//! auroraview pack --frontend ./dist --backend ./backend:main --embed-python
//! ```

use super::config::PackConfig;
use super::PackResult;

/// PyEmbed configuration for the generated project
#[derive(Debug, Clone)]
pub struct PyEmbedConfig {
    /// Python version to embed (e.g., "3.11", "3.12")
    pub python_version: String,
    /// Entry point module and function (e.g., "myapp:main")
    pub entry_point: Option<String>,
    /// Additional Python packages to include
    pub packages: Vec<String>,
    /// Whether to include pip in the embedded environment
    pub include_pip: bool,
    /// Optimization level for Python bytecode (0, 1, or 2)
    pub optimize: u8,
}

impl Default for PyEmbedConfig {
    fn default() -> Self {
        Self {
            python_version: "3.11".to_string(),
            entry_point: None,
            packages: Vec::new(),
            include_pip: false,
            optimize: 1,
        }
    }
}

impl PyEmbedConfig {
    /// Create a new PyEmbed configuration with an entry point
    pub fn with_entry_point(entry_point: &str) -> Self {
        Self {
            entry_point: Some(entry_point.to_string()),
            ..Default::default()
        }
    }

    /// Add packages to include in the embedded environment
    pub fn with_packages(mut self, packages: Vec<String>) -> Self {
        self.packages = packages;
        self
    }

    /// Set the Python version
    pub fn with_python_version(mut self, version: &str) -> Self {
        self.python_version = version.to_string();
        self
    }
}

/// Generate PyOxidizer configuration file (pyoxidizer.bzl)
pub fn generate_pyoxidizer_config(
    config: &PackConfig,
    pyembed_config: &PyEmbedConfig,
) -> PackResult<String> {
    let app_name = &config.output_name;
    let python_version = &pyembed_config.python_version;

    let entry_point_code = if let Some(ref entry) = pyembed_config.entry_point {
        let parts: Vec<&str> = entry.split(':').collect();
        if parts.len() == 2 {
            format!(
                r#"
    # Run the entry point
    run_code = "from {} import {}; {}()"
"#,
                parts[0], parts[1], parts[1]
            )
        } else {
            format!(
                r#"
    # Run the module directly
    run_module = "{}"
"#,
                entry
            )
        }
    } else {
        String::new()
    };

    let packages_code = if !pyembed_config.packages.is_empty() {
        let pkgs: Vec<String> = pyembed_config
            .packages
            .iter()
            .map(|p| format!("        \"{}\",", p))
            .collect();
        format!(
            r#"
    # Additional packages
    pip_install(
        packages=[
{}
        ],
    )
"#,
            pkgs.join("\n")
        )
    } else {
        String::new()
    };

    Ok(format!(
        r#"# PyOxidizer configuration for {app_name}
# Generated by AuroraView Pack

def make_exe():
    dist = default_python_distribution(python_version="{python_version}")
    
    policy = dist.make_python_packaging_policy()
    policy.resources_location = "in-memory"
    policy.resources_location_fallback = "filesystem-relative:lib"
    
    python_config = dist.make_python_interpreter_config()
    python_config.run_command = None
    python_config.optimization_level = {optimize}
    {entry_point_code}
    exe = dist.to_python_executable(
        name="{app_name}",
        packaging_policy=policy,
        config=python_config,
    )
    {packages_code}
    return exe

def make_install(exe):
    files = FileManifest()
    files.add_python_resource(".", exe)
    return files

register_target("exe", make_exe)
register_target("install", make_install, depends=["exe"], default=True)
resolve_targets()
"#,
        app_name = app_name,
        python_version = python_version,
        optimize = pyembed_config.optimize,
        entry_point_code = entry_point_code,
        packages_code = packages_code,
    ))
}

/// Generate Cargo.toml with pyembed dependency
///
/// Note: Currently unused as we use Askama templates instead,
/// but kept for potential future direct generation needs.
#[allow(dead_code)]
pub fn generate_cargo_toml_with_pyembed(
    config: &PackConfig,
    embed_assets: bool,
) -> PackResult<String> {
    let name = &config.output_name;

    let rust_embed_dep = if embed_assets {
        r#"rust-embed = { version = "8.5", features = ["compression"] }"#
    } else {
        ""
    };

    Ok(format!(
        r#"[package]
name = "{name}"
version = "0.1.0"
edition = "2021"

[dependencies]
wry = "0.50"
tao = "0.33"
{rust_embed}
# PyEmbed for embedded Python runtime
pyembed = {{ git = "https://github.com/loonghao/PyOxidizer", branch = "auroraview-maintained" }}

[build-dependencies]
pyo3-build-config = {{ version = "0.22", features = ["resolve-config"] }}

[[bin]]
name = "{name}"
path = "src/main.rs"
"#,
        name = name,
        rust_embed = rust_embed_dep,
    ))
}

/// Generate main.rs with embedded Python support
///
/// Note: Currently unused as we use Askama templates instead,
/// but kept for potential future direct generation needs.
#[allow(dead_code)]
pub fn generate_main_with_python(
    config: &PackConfig,
    pyembed_config: &PyEmbedConfig,
) -> PackResult<String> {
    let title = &config.window_title;
    let width = config.window_width;
    let height = config.window_height;

    let entry_point_call = if let Some(ref entry) = pyembed_config.entry_point {
        let parts: Vec<&str> = entry.split(':').collect();
        if parts.len() == 2 {
            format!(
                r#"
    // Import and call entry point
    Python::with_gil(|py| {{
        let module = PyModule::import(py, "{}")?;
        module.getattr("{}")?.call0()?;
        Ok::<(), PyErr>(())
    }})?;
"#,
                parts[0], parts[1]
            )
        } else {
            format!(
                r#"
    // Run module
    Python::with_gil(|py| {{
        py.run("{}", None, None)?;
        Ok::<(), PyErr>(())
    }})?;
"#,
                entry
            )
        }
    } else {
        String::new()
    };

    Ok(format!(
        r#"//! {title} - AuroraView Standalone Application with Embedded Python
//!
//! Generated by AuroraView Pack with PyOxidizer integration

use std::error::Error;
use tao::{{
    event::{{Event, WindowEvent}},
    event_loop::{{ControlFlow, EventLoop}},
    window::WindowBuilder,
}};
use wry::WebViewBuilder;

// PyEmbed imports
use pyembed::{{MainPythonInterpreter, OxidizedPythonInterpreterConfig}};

fn main() -> Result<(), Box<dyn Error>> {{
    // Initialize Python interpreter
    let config = OxidizedPythonInterpreterConfig::default();
    let interp = MainPythonInterpreter::new(config)?;

    // Run Python initialization
    interp.with_gil(|py| {{
        println!("[Python] Interpreter initialized: {{}}", py.version());
        Ok::<(), Box<dyn Error>>(())
    }})?;
    {entry_point_call}
    // Create window and WebView
    let event_loop = EventLoop::new();
    let window = WindowBuilder::new()
        .with_title("{title}")
        .with_inner_size(tao::dpi::LogicalSize::new({width}, {height}))
        .build(&event_loop)?;

    let _webview = WebViewBuilder::new(&window)
        .with_url("about:blank")?
        .build()?;

    event_loop.run(move |event, _, control_flow| {{
        *control_flow = ControlFlow::Wait;

        if let Event::WindowEvent {{
            event: WindowEvent::CloseRequested,
            ..
        }} = event
        {{
            *control_flow = ControlFlow::Exit;
        }}
    }});
}}
"#,
        title = title,
        width = width,
        height = height,
        entry_point_call = entry_point_call,
    ))
}

/// Check if pyembed is available and properly configured
pub fn check_pyembed_availability() -> PackResult<bool> {
    // For now, just check if the feature is enabled
    #[cfg(feature = "pyembed-runtime")]
    {
        Ok(true)
    }
    #[cfg(not(feature = "pyembed-runtime"))]
    {
        Ok(false)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pyembed_config_default() {
        let config = PyEmbedConfig::default();
        assert_eq!(config.python_version, "3.11");
        assert!(config.entry_point.is_none());
        assert!(config.packages.is_empty());
    }

    #[test]
    fn test_pyembed_config_with_entry_point() {
        let config = PyEmbedConfig::with_entry_point("myapp:main");
        assert_eq!(config.entry_point, Some("myapp:main".to_string()));
    }

    #[test]
    fn test_generate_pyoxidizer_config() {
        let pack_config = PackConfig::url("https://example.com").with_output("test-app");
        let pyembed_config = PyEmbedConfig::with_entry_point("backend:main");

        let result = generate_pyoxidizer_config(&pack_config, &pyembed_config);
        assert!(result.is_ok());

        let content = result.unwrap();
        assert!(content.contains("test-app"));
        assert!(content.contains("backend"));
        assert!(content.contains("main"));
    }
}
